# coding: utf-8

"""
    cloudharness

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from cloudharness_model.models.application_accounts_config import ApplicationAccountsConfig
from cloudharness_model.models.application_dependencies_config import ApplicationDependenciesConfig
from cloudharness_model.models.application_probe import ApplicationProbe
from cloudharness_model.models.application_test_config import ApplicationTestConfig
from cloudharness_model.models.database_deployment_config import DatabaseDeploymentConfig
from cloudharness_model.models.deployment_auto_artifact_config import DeploymentAutoArtifactConfig
from cloudharness_model.models.dockerfile_config import DockerfileConfig
from cloudharness_model.models.file_resources_config import FileResourcesConfig
from cloudharness_model.models.jupyter_hub_config import JupyterHubConfig
from cloudharness_model.models.name_value import NameValue
from cloudharness_model.models.named_object import NamedObject
from cloudharness_model.models.proxy_conf import ProxyConf
from cloudharness_model.models.service_auto_artifact_config import ServiceAutoArtifactConfig
from cloudharness_model.models.uri_role_mapping_config import UriRoleMappingConfig
from typing import Optional, Set
from typing_extensions import Self

class ApplicationHarnessConfig(BaseModel):
    """
    Define helm variables that allow CloudHarness to enable and configure your  application's deployment
    """ # noqa: E501
    deployment: Optional[DeploymentAutoArtifactConfig] = None
    service: Optional[ServiceAutoArtifactConfig] = None
    subdomain: Optional[StrictStr] = Field(default=None, description="If specified, an ingress will be created at [subdomain].[.Values.domain]")
    aliases: Optional[List[StrictStr]] = Field(default=None, description="If specified, an ingress will be created at [alias].[.Values.domain] for each alias")
    domain: Optional[StrictStr] = Field(default=None, description="If specified, an ingress will be created at [domain]")
    dependencies: Optional[ApplicationDependenciesConfig] = None
    secured: Optional[StrictBool] = Field(default=None, description="When true, the application is shielded with a getekeeper")
    uri_role_mapping: Optional[List[UriRoleMappingConfig]] = Field(default=None, description="Map uri/roles to secure with the Gatekeeper (if `secured: true`)")
    secrets: Optional[Dict[str, Any]] = None
    use_services: Optional[List[NamedObject]] = Field(default=None, description="Specify which services this application uses in the frontend to create proxy ingresses. e.g.  ``` - name: samples ```")
    database: Optional[DatabaseDeploymentConfig] = None
    resources: Optional[List[FileResourcesConfig]] = Field(default=None, description="Application file resources. Maps from deploy/resources folder and mounts as configmaps")
    readiness_probe: Optional[ApplicationProbe] = Field(default=None, alias="readinessProbe")
    startup_probe: Optional[ApplicationProbe] = Field(default=None, alias="startupProbe")
    liveness_probe: Optional[ApplicationProbe] = Field(default=None, alias="livenessProbe")
    source_root: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, alias="sourceRoot")
    name: Optional[StrictStr] = Field(default=None, description="Application's name. Do not edit, the value is automatically set from the application directory's name")
    jupyterhub: Optional[JupyterHubConfig] = None
    accounts: Optional[ApplicationAccountsConfig] = None
    test: Optional[ApplicationTestConfig] = None
    quotas: Optional[Dict[str, Any]] = None
    env: Optional[List[NameValue]] = Field(default=None, description="Environmental variables added to all containers (deprecated, please use envmap)")
    envmap: Optional[Dict[str, Any]] = None
    dockerfile: Optional[DockerfileConfig] = None
    sentry: Optional[StrictBool] = None
    proxy: Optional[ProxyConf] = None
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["deployment", "service", "subdomain", "aliases", "domain", "dependencies", "secured", "uri_role_mapping", "secrets", "use_services", "database", "resources", "readinessProbe", "startupProbe", "livenessProbe", "sourceRoot", "name", "jupyterhub", "accounts", "test", "quotas", "env", "envmap", "dockerfile", "sentry", "proxy"]

    @field_validator('source_root')
    def source_root_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^[^<>:;,?*|]+$", value):
            raise ValueError(r"must validate the regular expression /^[^<>:;,?*|]+$/")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ApplicationHarnessConfig from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of deployment
        if self.deployment:
            _dict['deployment'] = self.deployment.to_dict()
        # override the default output from pydantic by calling `to_dict()` of service
        if self.service:
            _dict['service'] = self.service.to_dict()
        # override the default output from pydantic by calling `to_dict()` of dependencies
        if self.dependencies:
            _dict['dependencies'] = self.dependencies.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in uri_role_mapping (list)
        _items = []
        if self.uri_role_mapping:
            for _item in self.uri_role_mapping:
                if _item:
                    _items.append(_item.to_dict())
            _dict['uri_role_mapping'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in use_services (list)
        _items = []
        if self.use_services:
            for _item in self.use_services:
                if _item:
                    _items.append(_item.to_dict())
            _dict['use_services'] = _items
        # override the default output from pydantic by calling `to_dict()` of database
        if self.database:
            _dict['database'] = self.database.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in resources (list)
        _items = []
        if self.resources:
            for _item in self.resources:
                if _item:
                    _items.append(_item.to_dict())
            _dict['resources'] = _items
        # override the default output from pydantic by calling `to_dict()` of readiness_probe
        if self.readiness_probe:
            _dict['readinessProbe'] = self.readiness_probe.to_dict()
        # override the default output from pydantic by calling `to_dict()` of startup_probe
        if self.startup_probe:
            _dict['startupProbe'] = self.startup_probe.to_dict()
        # override the default output from pydantic by calling `to_dict()` of liveness_probe
        if self.liveness_probe:
            _dict['livenessProbe'] = self.liveness_probe.to_dict()
        # override the default output from pydantic by calling `to_dict()` of jupyterhub
        if self.jupyterhub:
            _dict['jupyterhub'] = self.jupyterhub.to_dict()
        # override the default output from pydantic by calling `to_dict()` of accounts
        if self.accounts:
            _dict['accounts'] = self.accounts.to_dict()
        # override the default output from pydantic by calling `to_dict()` of test
        if self.test:
            _dict['test'] = self.test.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in env (list)
        _items = []
        if self.env:
            for _item in self.env:
                if _item:
                    _items.append(_item.to_dict())
            _dict['env'] = _items
        # override the default output from pydantic by calling `to_dict()` of dockerfile
        if self.dockerfile:
            _dict['dockerfile'] = self.dockerfile.to_dict()
        # override the default output from pydantic by calling `to_dict()` of proxy
        if self.proxy:
            _dict['proxy'] = self.proxy.to_dict()
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ApplicationHarnessConfig from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "deployment": DeploymentAutoArtifactConfig.from_dict(obj["deployment"]) if obj.get("deployment") is not None else None,
            "service": ServiceAutoArtifactConfig.from_dict(obj["service"]) if obj.get("service") is not None else None,
            "subdomain": obj.get("subdomain"),
            "aliases": obj.get("aliases"),
            "domain": obj.get("domain"),
            "dependencies": ApplicationDependenciesConfig.from_dict(obj["dependencies"]) if obj.get("dependencies") is not None else None,
            "secured": obj.get("secured"),
            "uri_role_mapping": [UriRoleMappingConfig.from_dict(_item) for _item in obj["uri_role_mapping"]] if obj.get("uri_role_mapping") is not None else None,
            "secrets": obj.get("secrets"),
            "use_services": [NamedObject.from_dict(_item) for _item in obj["use_services"]] if obj.get("use_services") is not None else None,
            "database": DatabaseDeploymentConfig.from_dict(obj["database"]) if obj.get("database") is not None else None,
            "resources": [FileResourcesConfig.from_dict(_item) for _item in obj["resources"]] if obj.get("resources") is not None else None,
            "readinessProbe": ApplicationProbe.from_dict(obj["readinessProbe"]) if obj.get("readinessProbe") is not None else None,
            "startupProbe": ApplicationProbe.from_dict(obj["startupProbe"]) if obj.get("startupProbe") is not None else None,
            "livenessProbe": ApplicationProbe.from_dict(obj["livenessProbe"]) if obj.get("livenessProbe") is not None else None,
            "sourceRoot": obj.get("sourceRoot"),
            "name": obj.get("name"),
            "jupyterhub": JupyterHubConfig.from_dict(obj["jupyterhub"]) if obj.get("jupyterhub") is not None else None,
            "accounts": ApplicationAccountsConfig.from_dict(obj["accounts"]) if obj.get("accounts") is not None else None,
            "test": ApplicationTestConfig.from_dict(obj["test"]) if obj.get("test") is not None else None,
            "quotas": obj.get("quotas"),
            "env": [NameValue.from_dict(_item) for _item in obj["env"]] if obj.get("env") is not None else None,
            "envmap": obj.get("envmap"),
            "dockerfile": DockerfileConfig.from_dict(obj["dockerfile"]) if obj.get("dockerfile") is not None else None,
            "sentry": obj.get("sentry"),
            "proxy": ProxyConf.from_dict(obj["proxy"]) if obj.get("proxy") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj


