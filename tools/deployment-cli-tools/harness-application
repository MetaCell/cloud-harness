#!/usr/bin/env python

import json
import pathlib
import sys
import os
import re
import shutil
import tempfile
import subprocess
import logging
import argparse

from ch_cli_tools import CH_ROOT
from cloudharness_utils.constants import APPLICATION_TEMPLATE_PATH
from ch_cli_tools.openapi import generate_server, generate_fastapi_server, APPLICATIONS_SRC_PATH, generate_ts_client
from ch_cli_tools.utils import merge_configuration_directories, replaceindir, replace_in_file, \
    to_python_module, copymergedir, get_json_template, replace_in_dict

try:
    from enum import StrEnum
except ImportError:
    from strenum import StrEnum

# Only allow lowercased alphabetical characters separated by "-".
name_pattern = re.compile("[a-z]+((-)?[a-z])?")

PLACEHOLDER = '__APP_NAME__'


class TemplateType(StrEnum):
    BASE = 'base'
    FLASK_SERVER = 'flask-server'
    WEBAPP = 'webapp'
    DB_POSTGRES = 'db-postgres'
    DB_NEO4J = 'db-neo4j'
    DB_MONGO = 'db-mongo'
    DJANGO_APP = 'django-app'
    SERVER = 'server'


def main():
    app_name, templates = get_command_line_arguments()

    app_path = os.path.join(APPLICATIONS_SRC_PATH, app_name)
    os.makedirs(app_path, exist_ok=True)

    if TemplateType.DJANGO_APP in templates and TemplateType.WEBAPP not in templates:
        templates = [TemplateType.BASE, TemplateType.WEBAPP, TemplateType.DB_POSTGRES] + templates

    if TemplateType.WEBAPP in templates:
        handle_webapp_template(app_name, app_path)

    if TemplateType.SERVER in templates:
        handle_server_template(app_path)

    for template_name in templates:
        merge_template_directories(template_name, app_path)

    if TemplateType.FLASK_SERVER in templates:
        handle_flask_server_template(app_path)

    replace_in_file(os.path.join(app_path, 'api/config.json'), PLACEHOLDER, to_python_module(app_name))

    if TemplateType.DJANGO_APP in templates:
        handle_django_app_template(app_name, app_path)

    replaceindir(app_path, PLACEHOLDER, app_name)

    if TemplateType.WEBAPP in templates:
        handle_webapp_template_cleanup(app_path)


def get_command_line_arguments() -> tuple[str, list[str]]:
    parser = argparse.ArgumentParser(description='Creates a new Application.')

    parser.add_argument('name', metavar='name', type=str,
                        help='Application name')
    parser.add_argument('-t', '--template',
                        dest='templates',
                        action="append",
                        default=[TemplateType.BASE],
                        type=str,
                        help="""Add a template name.

                        Available templates:
                        - flask-server (backend flask server based on openapi)
                        - webapp (React webapp including backend and frontend)
                        - db-postgres
                        - db-neo4j
                        - db-mongo
                        - django-app (fastapi django backend based on openapi)
                        """)
    args, unknown = parser.parse_known_args(sys.argv[1:])

    if unknown:
        print('There are unknown args. Make sure to call the script with the accepted args. Try --help')
        print(f'unknown: {unknown}')
        exit(1)

    try:
        match = name_pattern.match(args.name)
        if not match:
            print("Invalid application name")
            print(
                f"Application name must start and end with lowercased alphabetical characters and may contain '-' as separator. Used expression: '{name_pattern.pattern}'")
            exit(1)
    except re.error:
        print("Invalid regex")
        exit(1)

    return args.name, args.templates


def handle_webapp_template(app_name: str, app_path: str) -> None:
    app_path = pathlib.Path(app_path)
    frontend_app_path = app_path / 'frontend'

    if os.path.exists(frontend_app_path):
        shutil.rmtree(frontend_app_path)

    create_vite_skaffold(app_name, app_path)
    install_frontend_dependencies(app_path)

    shutil.move(app_path / app_name, frontend_app_path)
    generate_ts_client(openapi_file=app_path / 'api' / 'openapi.yaml')


def create_vite_skaffold(app_name: str, app_path: pathlib.Path) -> None:
    command = ['yarn', 'create', 'vite', app_name, '--template', 'react-ts']
    logging.info(f'Running command: {" ".join(command)}')
    subprocess.run(command, cwd=app_path)


def install_frontend_dependencies(app_path: pathlib.Path) -> None:
    command = ['yarn', 'install']
    logging.info(f'Running command: {" ".join(command)}')
    subprocess.run(command, cwd=app_path)


def handle_webapp_template_cleanup(app_path: str) -> None:
    try:
        os.remove(os.path.join(app_path, 'backend', 'Dockerfile'))
    except FileNotFoundError:
        # backend dockerfile not found, continue
        pass


def handle_server_template(app_path: str) -> None:
    with tempfile.TemporaryDirectory() as tmp_dirname:
        copymergedir(os.path.join(CH_ROOT, APPLICATION_TEMPLATE_PATH, TemplateType.SERVER), tmp_dirname)
        merge_configuration_directories(app_path, tmp_dirname)
        generate_server(app_path, tmp_dirname)


def handle_flask_server_template(app_path: str) -> None:
    generate_server(app_path)


def handle_django_app_template(app_name: str, app_path: str) -> None:
    replace_in_file(os.path.join(app_path, 'api/templates/main.jinja2'), PLACEHOLDER, to_python_module(app_name))
    generate_fastapi_server(app_path)
    replace_in_file(
        os.path.join(app_path, 'deploy/values.yaml'),
        f"{PLACEHOLDER}:{PLACEHOLDER}",
        f"{to_python_module(app_name)}:{to_python_module(app_name)}"
    )
    replace_in_file(os.path.join(app_path, "dev-setup.sh"), PLACEHOLDER, app_name)
    create_django_app_vscode_debug_configuration(app_name)
    try:
        os.remove(os.path.join(app_path, 'backend', "__APP_NAME__", "__main__.py"))
    except FileNotFoundError:
        # backend dockerfile not found, continue
        pass


def create_django_app_vscode_debug_configuration(app_name: str):
    vscode_launch_path = pathlib.Path('.vscode/launch.json')
    configuration_name = f'{app_name} backend'

    launch_config = get_json_template(vscode_launch_path, True)

    launch_config['configurations'] = [
        configuration for configuration in launch_config['configurations']
        if configuration['name'] != configuration_name
    ]

    debug_config = get_json_template('vscode-django-app-debug-template.json', True)
    debug_config = replace_in_dict(debug_config, PLACEHOLDER, app_name)

    launch_config['configurations'].append(debug_config)

    vscode_launch_path.parent.mkdir(parents=True, exist_ok=True)
    with vscode_launch_path.open('w') as f:
        json.dump(launch_config, f, indent=2, sort_keys=True)


def merge_template_directories(template_name: str, app_path: str) -> None:
    for base_path in (CH_ROOT, os.getcwd()):
        template_path = os.path.join(base_path, APPLICATION_TEMPLATE_PATH, template_name)
        if os.path.exists(template_path):
            merge_configuration_directories(template_path, app_path)


if __name__ == "__main__":
    main()
