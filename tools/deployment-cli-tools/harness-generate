#!/usr/bin/env python

import argparse
from dataclasses import dataclass
import glob
import os
import pathlib
import shutil
import sys
import logging
from typing import Callable, Optional

from ch_cli_tools.openapi import LIB_NAME, generate_python_client, generate_server, generate_fastapi_server, \
    get_dependencies, generate_ts_client, generate_model
from ch_cli_tools.utils import copymergedir

HERE = os.path.dirname(os.path.realpath(__file__))
ROOT = os.path.dirname(HERE)


@dataclass(frozen=True)
class CommandLineArguments:
    path: pathlib.Path
    client_name: str
    app_name: Optional[str]
    generate_clients: bool
    generate_models: bool
    is_interactive: bool


def main():
    args = get_command_line_arguments()
    get_dependencies()

    path_arg = pathlib.Path(args.path)
    root_path = path_arg if path_arg.is_absolute else path_arg.absolute
    library_models_path = root_path/'libraries'/'models'

    should_generate = should_generate_interactive if args.is_interactive else lambda _: True

    if args.generate_models and library_models_path.exists() and should_generate('the main model'):
        generate_model()

    if args.app_name or not (args.generate_clients or args.generate_models):
        generate_servers(root_path, should_generate, args.app_name)

    if args.generate_clients or not (args.app_name or args.generate_models):
        generate_clients(root_path, should_generate, args.client_name)


def get_command_line_arguments() -> CommandLineArguments:
    parser = argparse.ArgumentParser(description='Walk filesystem inside ./applications create application scaffolding.')

    parser.add_argument('path', metavar='path', default=ROOT, type=str,
                        help='Base path of the application.')
    parser.add_argument('-cn', '--client-name', dest='client_name', action="store", default=LIB_NAME,
                        help='Specify image registry prefix')
    parser.add_argument('-i', '--interactive', dest='interactive', action="store_true",
                        help='Asks before generate')
    parser.add_argument('-a', '--app_name', dest='app_name', action="store", default=None,
                        help='Generate only for a specific application')
    parser.add_argument('-c', '--clients', dest='clients', action="store_true",
                        help='Generate only client libraries')
    parser.add_argument('-m', '--models', dest='models', action="store_true",
                        help='Generate only model library')

    args, _ = parser.parse_known_args(sys.argv[1:])

    return CommandLineArguments(
        path=args.path,
        client_name=args.client_name,
        app_name=args.app_name,
        generate_clients=args.clients,
        generate_models=args.models,
        is_interactive=args.interactive,
    )


def should_generate_interactive(resource: str) -> bool:
    user_input = input(f'Do you want to generate {resource}? [Y/n]').casefold()

    return user_input == 'y'


def generate_servers(root_path: pathlib.Path, should_generate: Callable[[str], bool], app_name: Optional[str]):
    """
    Generates server stubs
    """
    openapi_files = get_openapi_file_paths(root_path)

    for openapi_file in openapi_files:
        if not should_generate(openapi_file):
            continue

        application_root = openapi_file.parent.parent
        current_app_name = application_root.name

        if app_name and current_app_name != app_name:
            continue

        genapi_path = application_root/'api'/'genapi.sh'
        if genapi_path.exists():
            # fastapi server --> use the genapi.sh script
            generate_fastapi_server(application_root)
        else:
            generate_server(application_root)


def generate_clients(root_path: pathlib.Path, should_generate: Callable[[str], bool], client_lib_name: str):
    """
    Generates client stubs
    """
    if not should_generate('client libraries'):
        return

    openapi_files = get_openapi_file_paths(root_path)
    client_src_path = root_path/'libraries'/'client'/client_lib_name

    for openapi_file in openapi_files:
        app_name = openapi_file.parent.parent.name

        generate_python_client(app_name, openapi_file, client_src_path, lib_name=client_lib_name)

        frontend_path = openapi_file.parent.parent/'frontend'
        if frontend_path.exists():
            generate_ts_client(openapi_file)

    aggregate_packages(str(client_src_path), client_lib_name)


def get_openapi_file_paths(root_path: pathlib.Path) -> list[pathlib.Path]:
    return [path for path in root_path.glob('applications/*/api/*.yaml')]


def aggregate_packages(client_src_path, lib_name=LIB_NAME):
    DOCS_PATH = os.path.join(client_src_path, 'docs')
    TEST_PATH = os.path.join(client_src_path, 'test')
    README = os.path.join(client_src_path, 'README.md')
    REQUIREMENTS = os.path.join(client_src_path, 'requirements.txt')
    TEST_REQUIREMENTS = os.path.join(client_src_path, 'test-requirements.txt')

    if not os.path.exists(DOCS_PATH):
        os.makedirs(DOCS_PATH)
    if not os.path.exists(TEST_PATH):
        os.makedirs(TEST_PATH)
    if os.path.exists(README):
        os.remove(README)
    if os.path.exists(REQUIREMENTS):
        os.remove(REQUIREMENTS)
    if os.path.exists(TEST_REQUIREMENTS):
        os.remove(TEST_REQUIREMENTS)

    req_lines_seen = set()
    test_req_lines_seen = set()

    for MODULE_TMP_PATH in glob.glob(client_src_path + '/tmp-*'):
        module = MODULE_TMP_PATH.split(
            f'{lib_name}/tmp-')[-1].replace('-', '_')

        # Moves package

        code_dest_dir = os.path.join(client_src_path, lib_name, module)
        copymergedir(os.path.join(MODULE_TMP_PATH,
                     lib_name, module), code_dest_dir)
        copymergedir(f"{MODULE_TMP_PATH}/{lib_name}.{module}",
                     code_dest_dir)  # Fixes a a bug with nested packages

        # Adds Docs
        module_doc_path = os.path.join(DOCS_PATH, module)
        if not os.path.exists(module_doc_path):
            os.mkdir(module_doc_path)
        copymergedir(f"{client_src_path}/tmp-{module}/docs", module_doc_path)

        # Adds Tests
        module_test_path = os.path.join(client_src_path, 'test', module)
        copymergedir(os.path.join(MODULE_TMP_PATH, 'test'), module_test_path)

        # Merges Readme
        readme_file = f"{MODULE_TMP_PATH}/README.md"
        if not os.path.exists(readme_file):
            logging.warning("Readme file not found: %s.", readme_file)
            continue
        with open(README, 'a+') as outfile:
            with open(readme_file) as infile:
                filedata = infile.read()
                fd = filedata.replace('docs/', f'docs/{module}/')
                outfile.write(fd)

        # Merges Requirements
        # FIXME: Different package versions will remain in the output file

        requirements_file = f"{MODULE_TMP_PATH}/requirements.txt"
        outfile = open(REQUIREMENTS, "a+")
        for line in open(requirements_file, "r"):
            if line not in req_lines_seen:
                outfile.write(line)
                req_lines_seen.add(line)
        outfile.close()

        # Merges Test Requirements
        # FIXME: Different package versions will remain in the output file
        test_requirements_file = f"{MODULE_TMP_PATH}/test-requirements.txt"
        outfile = open(TEST_REQUIREMENTS, "a+")
        for line in open(test_requirements_file, "r"):
            if line not in test_req_lines_seen:
                outfile.write(line)
                test_req_lines_seen.add(line)
        outfile.close()

        # Removes Tmp Files
        shutil.rmtree(MODULE_TMP_PATH)


if __name__ == "__main__":
    main()
