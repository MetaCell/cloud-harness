#!/usr/bin/env python

import argparse
from dataclasses import dataclass
import enum
import functools
import operator
import pathlib
import shutil
import logging
from typing import Callable, Optional

from ch_cli_tools.openapi import LIB_NAME, generate_python_client, generate_server, generate_fastapi_server, \
    get_dependencies, generate_ts_client, generate_model
from ch_cli_tools.utils import copymergedir


class ClientType(enum.Flag):
    TS_CLIENT = enum.auto()
    PYTHON_CLIENT = enum.auto()

    @classmethod
    def all(cls):
        return functools.reduce(operator.or_, cls)
    

class GenerationMode(enum.Flag):
    CLIENTS = enum.auto()
    MODELS = enum.auto()
    SERVERS = enum.auto()

    @classmethod
    def all(cls):
        return functools.reduce(operator.or_, cls)


@dataclass(frozen=True)
class CommandLineArguments:
    path: pathlib.Path
    app_name: Optional[str]
    is_interactive: bool
    generation_mode: GenerationMode
    client_name: Optional[str] = None
    client_types: ClientType = ClientType.all()

    @property
    def generate_models(self):
        return GenerationMode.MODELS in self.generation_mode

    @property
    def generate_servers(self):
        return GenerationMode.SERVERS in self.generation_mode

    @property
    def generate_clients(self):
        return GenerationMode.CLIENTS in self.generation_mode


def main():
    args = get_command_line_arguments()
    get_dependencies()

    root_path = args.path if args.path.is_absolute() else args.path.absolute()

    should_generate = should_generate_interactive if args.is_interactive else lambda _: True

    if args.generate_models:
        generate_models(root_path, should_generate)

    if args.generate_servers:
        generate_servers(root_path, should_generate, args.app_name)

    if args.generate_clients:
        assert args.client_name is not None
        generate_clients(root_path, should_generate, args.app_name, args.client_name, args.client_types)


def get_command_line_arguments() -> CommandLineArguments:
    parser = argparse.ArgumentParser(description='Walk filesystem inside ./applications create application scaffolding.')

    common_arguments = argparse.ArgumentParser(add_help=False)
    common_arguments.add_argument('path', metavar='path', nargs='?', default=pathlib.Path.cwd(), type=pathlib.Path,
                                  help='Base path of the application.')
    common_arguments.add_argument('-i', '--interactive', dest='is_interactive', action="store_true",
                        help='Asks before generate')
    common_arguments.add_argument('-a', '--app_name', dest='app_name', action="store", default=None,
                        help='Generate only for a specific application')

    clients_arguments = argparse.ArgumentParser(add_help=False)
    clients_arguments.add_argument('-cn', '--client-name', dest='client_name', action='store', default=LIB_NAME,
                                   help='specify image registry prefix')
    client_type_group = clients_arguments.add_mutually_exclusive_group(required=False)
    client_type_group.add_argument('-t', '--ts-only', dest='client_types', action='store_const', const=ClientType.TS_CLIENT,
                                   help='Generate only typescript clients')
    client_type_group.add_argument('-p', '--python-only', dest='client_types', action='store_const', const=ClientType.PYTHON_CLIENT,
                                   help='Generate only python clients')
    clients_arguments.set_defaults(client_types=ClientType.all())

    subparsers = parser.add_subparsers(title='generation modes', required=True)

    all_parser = subparsers.add_parser('all', parents=[common_arguments, clients_arguments],
                                       help='Generate models, server stubs and client libraries')
    all_parser.set_defaults(generation_mode=GenerationMode.all())

    models_parser = subparsers.add_parser('models', parents=[common_arguments],
                                          help='Generate only model library')
    models_parser.set_defaults(generation_mode=GenerationMode.MODELS)

    servers_parser = subparsers.add_parser('servers', parents=[common_arguments],
                                           help='Generate only server stubs')
    servers_parser.set_defaults(generation_mode=GenerationMode.SERVERS)

    clients_parser = subparsers.add_parser('clients', parents=[common_arguments, clients_arguments],
                                           help='Generate only client libraries')
    clients_parser.set_defaults(generation_mode=GenerationMode.CLIENTS)

    args = parser.parse_args()

    return CommandLineArguments(**args.__dict__)


def should_generate_interactive(resource: str) -> bool:
    user_input = input(f'Do you want to generate {resource}? [Y/n] ').casefold()

    return user_input == 'y'


def generate_models(
        root_path: pathlib.Path,
        should_generate: Callable[[str], bool],
) -> None:
    """
    Generates the main model
    """
    library_models_path = root_path/'libraries'/'models'

    if not library_models_path.exists():
        return

    if not should_generate('the main model'):
        return

    generate_model()


def generate_servers(
        root_path: pathlib.Path,
        should_generate: Callable[[str], bool],
        app_name: Optional[str],
) -> None:
    """
    Generates server stubs
    """
    openapi_files = get_openapi_file_paths(root_path)

    for openapi_file in openapi_files:
        application_root = openapi_file.parent.parent
        current_app_name = application_root.name

        if app_name and current_app_name != app_name:
            continue

        if not should_generate(f'server stubs for {openapi_file}'):
            continue

        genapi_path = application_root/'api'/'genapi.sh'
        if genapi_path.exists():
            # fastapi server --> use the genapi.sh script
            generate_fastapi_server(application_root)
        else:
            generate_server(application_root)


def generate_clients(
        root_path: pathlib.Path,
        should_generate: Callable[[str], bool],
        app_name: Optional[str],
        client_lib_name: str,
        client_types: ClientType,
) -> None:
    """
    Generates client stubs
    """
    if not should_generate('client libraries'):
        return

    openapi_files = get_openapi_file_paths(root_path)
    client_src_path = root_path/'libraries'/'client'/client_lib_name

    for openapi_file in openapi_files:
        current_app_name = openapi_file.parent.parent.name
        if app_name and current_app_name != app_name:
            continue

        if ClientType.PYTHON_CLIENT in client_types:
            generate_python_client(current_app_name, openapi_file, client_src_path, lib_name=client_lib_name)

        frontend_path = openapi_file.parent.parent/'frontend'
        if frontend_path.exists() and ClientType.TS_CLIENT in client_types:
            generate_ts_client(openapi_file)

    aggregate_packages(client_src_path, client_lib_name)


def get_openapi_file_paths(root_path: pathlib.Path) -> list[pathlib.Path]:
    return [path for path in root_path.glob('applications/*/api/*.yaml')]


def aggregate_packages(client_source_path: pathlib.Path, lib_name=LIB_NAME):
    client_source_path.mkdir(parents=True, exist_ok=True)

    client_docs_path = client_source_path/'docs'
    client_docs_path.mkdir(exist_ok=True)

    client_test_path = client_source_path/'test'
    client_test_path.mkdir(exist_ok=True)

    client_readme_file = client_source_path/'README.md'
    client_readme_file.unlink(missing_ok=True)

    client_requirements_file = client_source_path/'requirements.txt'
    client_requirements_file.unlink(missing_ok=True)

    client_test_requirements_file = client_source_path/'test-requirements.txt'
    client_test_requirements_file.unlink(missing_ok=True)

    requirements_lines_seen = set()
    test_requirements_lines_seen = set()

    for temp_module_path in client_source_path.glob('tmp-*/'):
        module = (
            temp_module_path
            .name
            .removeprefix('tmp-')
            .replace('-', '_')
        )

        code_destination_directory = client_source_path/lib_name/module
        copymergedir(temp_module_path/lib_name/module, code_destination_directory)
        copymergedir(temp_module_path/f'{lib_name}.{module}', code_destination_directory) # Fixes a bug with nested packages

        module_docs_path = client_docs_path/module
        module_docs_path.mkdir(parents=True, exist_ok=True)
        copymergedir(client_source_path/temp_module_path.name/'docs', module_docs_path)

        module_tests_path = client_source_path/'test'/module
        copymergedir(temp_module_path/'test', module_tests_path)

        readme_file = temp_module_path/'README.md'
        if not readme_file.exists():
            logging.warning(f'Readme file not found: {readme_file}.')
            continue

        with client_readme_file.open('+a') as out_file, readme_file.open('r') as in_file:
            file_data = in_file.read()
            updated_file_data = file_data.replace('docs/', f'docs/{module}/')
            out_file.write(updated_file_data)

        # FIXME: Different package versions will remain in the output file
        requirements_file = temp_module_path/'requirements.txt'
        with requirements_file.open('r') as in_file, client_requirements_file.open('+a') as out_file:
            unseen_lines = [line for line in in_file if line not in requirements_lines_seen]
            requirements_lines_seen.update(unseen_lines)
            out_file.writelines(unseen_lines)

        # FIXME: Different package versions will remain in the output file
        test_requirements_file = temp_module_path/'test-requirements.txt'
        with test_requirements_file.open('r') as in_file, client_test_requirements_file.open('+a') as out_file:
            unseen_lines = [line for line in in_file if line not in test_requirements_lines_seen]
            test_requirements_lines_seen.update(unseen_lines)
            out_file.writelines(unseen_lines)

        shutil.rmtree(temp_module_path)


if __name__ == "__main__":
    main()
