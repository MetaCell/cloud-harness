# Deployment generation and installation howto

## Create the deployment
The command `harness-deployment` scans your applications and configurations to create the build and deploy artifacts.
Created artifacts include:
 - Helm chart
 - Skaffold build and run configuration
 - Visual Studio Code debug and run configuration
 - Codefresh pipeline yaml specification (optional)

With your solution folder structure looking like

```
applications
deployment-configuration
infrastructure
cloud-harness
```

run

```
harness-deployment cloud-harness . [PARAMS]
```

to create the build and deployment artifacts for your solution.
See the dedicated [Build and deploy](./docs/build-deploy-howto.md) document for more details and examples.

### Parameters

Deployment definition:

- `--domain`, `-d`:  specify the base domain (default cloudharness.metacell.us)
- `--env`, `-e`: sets a custom configuration environment (example, dev, prod; default: none). Will load values-[ENV].yaml files. Specify multiple envs with dashes (e.g env1-env2)
- `--namespace`, `-n`: set the kubernetes namespace (default: ch)
- `--include`, `-i`: set application(s) to include (with their dependencies). If not set, every application will be included
- `--exclude`, `-ex`: explicitly exclude applications or task images
- `--docker-compose`: targets Docker Compose instead of Kubernetes (see [details below](#docker-compose-target))

Development parameters:
- `--local`, `-l`: creates internal dns for local deployment
- `-dtls`: disables the tls configurations on the ingress so everything will be available from plain http
- `--disable-security`, `-u`: disables all gatekeepers


CI/CD generation and build parameters
- `--tag`, `-t`: define build tag. Omit to generate hash-based tags
- `--registry`, `-r`: set the Docker registry where images are pushed on build
- `-we', '--write-env`: Write build env to .env file with variables about the generated image tags.
- `-cu`, `--cache-url`: Specify a custom cache URL for the docker images. This is used to speed up builds by caching layers. Example: https://cache.cloudharness.io?repository=[REGISTRY]/[IMAGE_NAME]&tag=[TAG]
- `-N`, `--no-cd`: Do not generate ci/cd files


Other
- `--output`, `-o`: specify helm chart base path (default `./deployment)

For a local build the command will look like:

```
harness-deployment cloud-harness . -u -dtls -l -d mydomain.local -e local -n mynamespace
```

To deploy on a remote cluster it is necessary to set a remote Docker registry that is visible to the cluster with the `--registry` parameter (see also following note).

For a remote development/test environment, the command will look like:

```
harness-deployment cloud-harness . -d mydomain.dev.org -n mynamespace -e dev -r `gcr.io/myregistry`
```

**Note: Docker registry**

By default `skaffold` builds the images in the local Docker registry. In order to make the deploy work, we need to specify a
registry that is visible from inside the cluster. The parameter `--registry` allows to specify a registry in which images are pushed after the build.
Any public registry will work. The suggested way to go is to install a registry on localhost:5000 inside
the kube cluster and push on that registry, also forwarded to localhost.

On minikube can use the registry addon:

`minikube addons enable registry`

Then forward with:
`kubectl port-forward --namespace kube-system $(kubectl get po -n kube-system | grep registry | grep -v proxy | \awk '{print $1;}') 5000:5000`

## Manually deploy on a kube cluster
The Kubernetes client `kubectl` must be set up and working on the local machine,
for instance with a Google Cloud cluster or a local Kubernetes like Minikube or Docker Desktop.

1. Locally build the images with `skaffold build`
1. Create the namespace `kubectl create ns ch`
1. Build images and Install or upgrade the helm chart with `skaffold deploy`

To build and reploy

## Continuous deployment with Codefresh

See [here](./ci-cd/codefresh.md).

## Relevant files and directory structure
Deployment files are automatically generated with the script
`harness-deployment`.

all the resources intended to install and deploy the platform on Kubernetes.
 - `codefresh`: codefresh build related files (automatically generated)
 - `deployment/helm`: the helm chart

What this script does is to go through all the defined applications and use templates to define all the required
definitions and variables.

General templates are defined inside `deployment-configuration`.

Applications can override templates values by defining a file `values.yaml` in the same directory of the Docker file.

## Notes about deployment generation

The following deployment files are generated by `harness-deployment`:

- Helm chart configuration for custom deployment: **./helm/values.yaml**
- Codefresh build and deploment definition: **./codefresh/codefresh.yaml**

The script `harness-deployment` also generates a build script to be used by codefresh.

The control on the content of those files can be achieved primarily by setting up a
custom `values.yaml` and deploy/templates in the application folder.
The files under
`deployment-configuration` can be also modified for general overrides.

Things to notice:

- Each image created during the build step will have to be deployed to a k8s cluster.
- A Helm chart was created under `deployment/helm` path to handle deployments.
- To populate the generated file `deployment/helm/values.yaml` is used.

## Docker compose target

Docker compose is partially supported as a deployment target as an alternative when Kubernetes
is not available option or for local development.

See [here](./docker-compose.md) for more information.

## Manual configurations

- [Configure user accounts](../accounts.md)

## Access and test
Applications are deployed in the default domain *.YOURDOMAIN.
In order to access the applications from your browser, set up your hosts file as indicated by the `harness-deployment` script output.

Example: after running `harness-deployment -d mydomain.local -i samples`, set
```
127.0.0.1  samples.mydomain.local workflows.mydomain.local events.mydomain.local argo.mydomain.local
```
